/**
 * LogService - Business Logic Layer for Log operations
 * 
 * Handles:
 * - Log creation with validation and timestamp generation
 * - Log retrieval by ID
 * - Log querying with filters and pagination
 * 
 * Requirements: 1.1, 1.2, 2.1, 2.2, 2.3, 2.4, 2.5
 */

import { LogInput, LogOutput, LogFilters, Pagination, PaginatedResult } from '../types';
import { logRepository, LogRepository } from '../repositories/LogRepository';
import { Log } from '../models/Log';
import { validateOrThrow } from '../validation/validator';
import { logInputSchema, logFiltersSchema, paginationSchema } from '../validation/schemas';
import { logger } from '../config/logger';

export class LogService {
  constructor(private repository: LogRepository = logRepository) {}

  /**
   * Creates a new log entry
   * 
   * @param logData - Log input data
   * @returns Promise resolving to the created log
   * @throws ValidationError if input is invalid
   * @throws DatabaseError if database operation fails
   * 
   * Requirements: 1.1, 1.2, 1.3, 1.4, 1.5
   */
  async createLog(logData: LogInput): Promise<LogOutput> {
    // Validate input data (Requirement 1.3, 1.4, 1.5)
    const validatedData = validateOrThrow<LogInput>(logInputSchema, logData);

    logger.info('Creating log entry', {
      deviceUuid: validatedData.deviceUuid,
      dataType: validatedData.dataType,
      key: validatedData.key,
    });

    // Create log with auto-generated timestamp (Requirement 1.2)
    const log = await this.repository.create({
      deviceUuid: validatedData.deviceUuid,
      dataType: validatedData.dataType,
      logKey: validatedData.key,
      logValue: validatedData.value,
      // createdAt will be auto-generated by the database
    });

    logger.info('Log entry created successfully', { id: log.id });

    return this.toLogOutput(log);
  }

  /**
   * Retrieves a log entry by ID
   * 
   * @param id - Log ID
   * @returns Promise resolving to the log or null if not found
   * @throws DatabaseError if database operation fails
   * 
   * Requirements: 2.1
   */
  async getLogById(id: number): Promise<LogOutput | null> {
    logger.debug('Retrieving log by ID', { id });

    const log = await this.repository.findById(id);

    if (!log) {
      logger.debug('Log not found', { id });
      return null;
    }

    return this.toLogOutput(log);
  }

  /**
   * Queries logs with filters and pagination
   * 
   * @param filters - Filter criteria
   * @param pagination - Pagination parameters
   * @returns Promise resolving to paginated results
   * @throws ValidationError if filters or pagination are invalid
   * @throws DatabaseError if database operation fails
   * 
   * Requirements: 2.1, 2.2, 2.3, 2.4, 2.5
   */
  async queryLogs(
    filters: LogFilters = {},
    pagination: Pagination = { page: 1, pageSize: 20 }
  ): Promise<PaginatedResult<LogOutput>> {
    // Validate filters and pagination
    const validatedFilters = validateOrThrow<LogFilters>(logFiltersSchema, filters);
    const validatedPagination = validateOrThrow<Pagination>(paginationSchema, pagination);

    logger.info('Querying logs', {
      filters: validatedFilters,
      pagination: validatedPagination,
    });

    // Query logs and count total
    const [logs, total] = await Promise.all([
      this.repository.findByFilters(validatedFilters, validatedPagination),
      this.repository.countByFilters(validatedFilters),
    ]);

    const totalPages = Math.ceil(total / validatedPagination.pageSize);

    logger.info('Query completed', {
      resultCount: logs.length,
      total,
      totalPages,
    });

    return {
      data: logs.map((log) => this.toLogOutput(log)),
      pagination: {
        page: validatedPagination.page,
        pageSize: validatedPagination.pageSize,
        total,
        totalPages,
      },
    };
  }

  /**
   * Converts a Log model instance to LogOutput format
   * @private
   */
  private toLogOutput(log: Log): LogOutput {
    return {
      id: log.id,
      deviceUuid: log.deviceUuid,
      dataType: log.dataType,
      key: log.logKey,
      value: log.logValue,
      createdAt: log.createdAt.toISOString(),
    };
  }
}

// Export singleton instance
export const logService = new LogService();
